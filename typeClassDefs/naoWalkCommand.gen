-author Carl Lusty

%c++
public:

static NaoWalkCommand walk(int16_t forward, int16_t left, int8_t turn) {
    NaoWalkCommand cmd = NaoWalkCommand();
    cmd.set_walkEngineOn(true);
    cmd.set_forward(forward);
    cmd.set_left(left);
    cmd.set_turn(turn);
    cmd.set_bend(1);
    return cmd;
}

static NaoWalkCommand walkPrecisely(int16_t forward, int16_t left, int8_t turn) {
    NaoWalkCommand cmd = walk(forward, left, turn);
    cmd.set_exactStepsRequested(true);
    return cmd;
}

static NaoWalkCommand stop() {
    NaoWalkCommand cmd = NaoWalkCommand();
    cmd.set_walkEngineOn(true);
    cmd.set_forward(0);
    cmd.set_left(0);
    cmd.set_turn(0);
    cmd.set_bend(1);
    return cmd;
}

static NaoWalkCommand standWithStiffness() {
    NaoWalkCommand cmd = stop();
    cmd.set_walkEngineOn(true);
    cmd.set_bend(1);
    return cmd;
}

static NaoWalkCommand standWithMinimalStiffness() {
    NaoWalkCommand cmd = stop();
    cmd.set_walkEngineOn(true);
    cmd.set_bend(0);
    return cmd;
}

static NaoWalkCommand disconnectWalk() {
    NaoWalkCommand cmd = NaoWalkCommand();
    cmd.set_walkEngineOn(false);
    return cmd;
}

-properties

bool walkEngineOn = false //connects the dcm callbacks. Essentially turning the walk on. When enabled, the walk engine controls all joint values except the head pitch and yaw.

int16_t forward = 0 //[-300 - 300] step-size(mm) per second, limited to +/- 300mm/step
int16_t left = 0    //[-200 - 200] step-size(mm) per second, limited to +/- 200mm/step
int8_t turn = 0     //[-85 - 85] step-size(mm) per second, limited to +/- 85deg/step

bool exactStepsRequested = false //No ratcheting, no speed 'buildup', just full step sizes. This is good for exact movements, like walk 23cm forward for a kick.
uint8_t speed = 100 //[0 - 100] modifier for forward etc.. when using exactStepsRequested = true
uint8_t odometryResetCounter = 0 //Odometry will reset any time this is changed or incremented.

bool isFast = false //for kicks. True results in a 'Jab'/rapid kick.
bool kickWithLeftFoot = true //which foot to use for kicking

bool useShuffle = false //limits the step height so the robot 'shuffles' instead of taking larger steps. Good for walking near other robots or small obstacles that could trip the robot, if it tried to step onto it.

bool leftArmLimp = true //lower stiffness in the arms when walking, allows the arm to move a little more. This is for robot collisions to allow the arm to absorb some of the collision instead of rigidly transferring the force to the whole body.
bool rightArmLimp = true //lower stiffness in the arms when walking, allows the arm to move a little more. This is for robot collisions to allow the arm to absorb some of the collision instead of rigidly transferring the force to the whole body.

uint8_t power = 0   //[0 - 100] stiffness, auto set to minimum needed values. Advanced pararm! don't alter this without knowledge of exactly what it does.

uint8_t bend = 0   //[0 - 1] controls what the robot does when stopped, 0 == STAND and lower stiffness, 1 == stay in READY, crouched and ready to walk immediately.


-comment
Control message for sending commands to the walk engine created by UNSW.
LICENSE:
https://github.com/UNSWComputing/rUNSWift-2017-release/blob/master/LICENSE
Source:
https://github.com/UNSWComputing/rUNSWift-2017-release/blob/master/robot/motion/generator/Walk2014Generator.cpp
Some of their documentation:
https://github.com/UNSWComputing/rUNSWift-2017-release/wiki/Motion#walk2014-generator

