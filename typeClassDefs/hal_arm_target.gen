-author    Dimitri Joukoff

-c
#define LEFT_ARM ((uint8_t)0)
#define RIGHT_ARM ((uint8_t)1)

/** Issued Commands that exceed the movement limits given below
 *  are treated as NO-OP.  I.e. the pose of the joint is not altered
 *  by the command.
 */

/** Limits expressed in degrees */
#define SHOULDER_PITCH_LIMIT_DOWN_DEG 119.5f
#define SHOULDER_PITCH_LIMIT_UP_DEG -SHOULDER_PITCH_LIMIT_DOWN_DEG

#define LEFT_SHOULDER_ROLL_OUT_DEG 76.0f
#define LEFT_SHOULDER_ROLL_IN_DEG -18.0f
#define RIGHT_SHOULDER_ROLL_OUT_DEG -LEFT_SHOULDER_ROLL_OUT_DEG
#define RIGHT_SHOULDER_ROLL_IN_DEG -LEFT_SHOULDER_ROLL_IN_DEG

#define LEFT_ELBOW_ROLL_STRAIGHT_DEG -2.0f
#define LEFT_ELBOW_ROLL_BENT_DEG -88.5f
#define RIGHT_ELBOW_ROLL_STRAIGHT_DEG -LEFT_ELBOW_ROLL_STRAIGHT_DEG
#define RIGHT_ELBOW_ROLL_BENT_DEG -LEFT_ELBOW_ROLL_BENT_DEG

#define LEFT_ELBOW_YAW_RIGHT_DEG 119.5f
#define LEFT_ELBOW_YAW_LEFT_DEG -LEFT_ELBOW_YAW_RIGHT_DEG
#define RIGHT_ELBOW_YAW_RIGHT_DEG LEFT_ELBOW_YAW_RIGHT_DEG
#define RIGHT_ELBOW_YAW_LEFT_DEG -LEFT_ELBOW_YAW_RIGHT_DEG

#define LEFT_WRIST_YAW_RIGHT_DEG 104.5f
#define LEFT_WRIST_YAW_LEFT_DEG -LEFT_WRIST_YAW_RIGHT_DEG
#define RIGHT_WRIST_YAW_RIGHT_DEG LEFT_WRIST_YAW_RIGHT_DEG
#define RIGHT_WRIST_YAW_LEFT_DEG -LEFT_WRIST_YAW_RIGHT_DEG

/** Limits expressed in radians */
#define SHOULDER_PITCH_LIMIT_DOWN_RAD 2.0857f
#define SHOULDER_PITCH_LIMIT_UP_RAD -SHOULDER_PITCH_LIMIT_DOWN_RAD

#define LEFT_SHOULDER_ROLL_OUT_RAD 1.3265f
#define LEFT_SHOULDER_ROLL_IN_RAD -0.3142f
#define RIGHT_SHOULDER_ROLL_OUT_RAD -LEFT_SHOULDER_ROLL_OUT_RAD
#define RIGHT_SHOULDER_ROLL_IN_RAD -LEFT_SHOULDER_ROLL_IN_RAD

#define LEFT_ELBOW_ROLL_STRAIGHT_RAD -0.0349f
#define LEFT_ELBOW_ROLL_BENT_RAD -1.5446f
#define RIGHT_ELBOW_ROLL_STRAIGHT_RAD -LEFT_ELBOW_ROLL_STRAIGHT_RAD
#define RIGHT_ELBOW_ROLL_BENT_RAD -LEFT_ELBOW_ROLL_BENT_RAD

#define LEFT_ELBOW_YAW_RIGHT_RAD 2.0857f
#define LEFT_ELBOW_YAW_LEFT_RAD -LEFT_ELBOW_YAW_RIGHT_RAD
#define RIGHT_ELBOW_YAW_RIGHT_RAD LEFT_ELBOW_YAW_RIGHT_RAD
#define RIGHT_ELBOW_YAW_LEFT_RAD -LEFT_ELBOW_YAW_RIGHT_RAD

#define LEFT_WRIST_YAW_RIGHT_RAD 1.8238f
#define LEFT_WRIST_YAW_LEFT_RAD -LEFT_WRIST_YAW_RIGHT_RAD
#define RIGHT_WRIST_YAW_RIGHT_RAD LEFT_WRIST_YAW_RIGHT_RAD
#define RIGHT_WRIST_YAW_LEFT_RAD -LEFT_WRIST_YAW_RIGHT_RAD

-properties

    int32_t   target_movement_time          =  INT_MAX     // The elapsed time, in mSec, in which the movement should be completed. Status Message: Absolute time when the current action will complete. (Thus this is an int32_t.)
    int16_t   target_shoulderpitch          =  0           // target shoulder pitch angle in 10ths of degrees
    int16_t   target_shoulderroll           =  0           // target shoulder roll angle angle in 10ths of degrees
    int16_t   target_elbowroll              =  0           // target elbow roll angle in 10ths of degrees
    int16_t   target_elbowyaw               =  0           // target elbow yaw angle in 10ths of degrees
    int16_t   target_wristyaw               =  0           // target wrist yaw angle in 10ths of degrees
    uint8_t   target_arm                    =  LEFT_ARM    // target arm number: This property is used strictly for accounting purposes when the struct is stored within an array and the robot has numerous  arms.
    uint8_t   target_hand                   =  0           // target hand grasper opening as a percentage: 0   gripper will be clasped shut, 100 gripper will be fully openned
    uint8_t   target_shoulderpitchstiffness =  0           // target shoulder pitch stiffness as a percentage
    uint8_t   target_shoulderrollstiffness  =  0           // target shoulder roll stiffness as a percentage
    uint8_t   target_elbowrollstiffness     =  0           // target elbow roll stiffness as a percentage
    uint8_t   target_elbowyawstiffness      =  0           // target elbow yaw stiffness as a percentage
    uint8_t   target_wristyawstiffness      =  0           // target wrist yaw stiffness as a percentage
    uint8_t   target_handstiffness          =  0           // target hand grasper stiffness as a percentage
    uint8_t   target_pliability             =  0          // target arm's pliability when in Passive Mode. When the arm is passive, this value reduces the update frequency, thus making the arm more resistant to external forces. Use of values from 0 to 10 is recommended. When set to zero (0), the Arm, when fully extended out, will fall under its own weight. Higher values stiffen the arm and reduce responsiveness, the movement will become stepped.
    bit       target_shoulderpitch_active   =  true        // Is the shoulderpitch Active (true[DEFAULT]) or Passive (false). Active :  The robot's DCM will prevent movement of the arm from the requested pose in accordance to the joint stiffness. (This is the normal behaviour of the robot.)  Passive:  Once the requested pose is achieved, the DCM will automatically update the requested pose according to deviations in the joints. The effect of this is that the robot's arm will be susceptible to gravity (and will fall slowly over time) as well as to externally applied forces (allowing it to be manipulated).
    bit       target_shoulderroll_active    =  true        // Is the shoulderroll Active (true[DEFAULT]) or Passive (false)
    bit       target_elbowroll_active       =  true        // Is the elbowroll Active (true[DEFAULT]) or Passive (false)
    bit       target_elbowyaw_active        =  true        // Is the elbowyaw Active (true[DEFAULT]) or Passive (false)
    bit       target_wrist_active           =  true        // Is the wrist Active (true[DEFAULT]) or Passive (false)
    bit       target_hand_active            =  true        // Is the hand Active (true[DEFAULT]) or Passive (false)
    bit       target_arm_at_goal            =  false       // Control Message: Not used. Status Message: Naoqiinterface reports that the goal location of all joints has been reached (within specified tolerance).
    bit       target_arm_stop               =  false       // Control Message: Stop the arm at its current location. Status Message: Indicates if the last control message issued a STOP command.

%c
#ifdef WHITEBOARD_POSTER_STRING_CONVERSION
/**
 * Convert to a string.
 */
const char* wb_hal_arm_target_value_description(const struct wb_hal_arm_target* self, char* toString, size_t bufferSize)
{
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-variable"
    size_t len = 0;
    if (len >= bufferSize) {
        return toString;
    }
    len += snprintf(toString + len, bufferSize - len, "%d", self->target_shoulderpitch);
    if (len >= bufferSize) {
        return toString;
    }
    len = gu_strlcat(toString, " | ", bufferSize);
    if (len >= bufferSize) {
        return toString;
    }
    len += snprintf(toString + len, bufferSize - len, "%d", self->target_shoulderroll);
    if (len >= bufferSize) {
        return toString;
    }
    len = gu_strlcat(toString, " | ", bufferSize);
    if (len >= bufferSize) {
        return toString;
    }
    len += snprintf(toString + len, bufferSize - len, "%d", self->target_elbowroll);
    if (len >= bufferSize) {
        return toString;
    }
    len = gu_strlcat(toString, " | ", bufferSize);
    if (len >= bufferSize) {
        return toString;
    }
    len += snprintf(toString + len, bufferSize - len, "%d", self->target_elbowyaw);
    if (len >= bufferSize) {
        return toString;
    }
    len = gu_strlcat(toString, " | ", bufferSize);
    if (len >= bufferSize) {
        return toString;
    }
    len += snprintf(toString + len, bufferSize - len, "%d", self->target_wristyaw);
    if (len >= bufferSize) {
        return toString;
    }
    len = gu_strlcat(toString, " | ", bufferSize);
    if (len >= bufferSize) {
        return toString;
    }
    len += snprintf(toString + len, bufferSize - len, "%u", self->target_hand);
    if (len >= bufferSize) {
        return toString;
    }
    len = gu_strlcat(toString, " | ", bufferSize);
    if (len >= bufferSize) {
        return toString;
    }
    len += snprintf(toString + len, bufferSize - len, "%u", self->target_shoulderpitchstiffness);
    if (len >= bufferSize) {
        return toString;
    }
    len = gu_strlcat(toString, " | ", bufferSize);
    if (len >= bufferSize) {
        return toString;
    }
    len += snprintf(toString + len, bufferSize - len, "%u", self->target_shoulderrollstiffness);
    if (len >= bufferSize) {
        return toString;
    }
    len = gu_strlcat(toString, " | ", bufferSize);
    if (len >= bufferSize) {
        return toString;
    }
    len += snprintf(toString + len, bufferSize - len, "%u", self->target_elbowrollstiffness);
    if (len >= bufferSize) {
        return toString;
    }
    len = gu_strlcat(toString, " | ", bufferSize);
    if (len >= bufferSize) {
        return toString;
    }
    len += snprintf(toString + len, bufferSize - len, "%u", self->target_elbowyawstiffness);
    if (len >= bufferSize) {
        return toString;
    }
    len = gu_strlcat(toString, " | ", bufferSize);
    if (len >= bufferSize) {
        return toString;
    }
    len += snprintf(toString + len, bufferSize - len, "%u", self->target_wristyawstiffness);
    if (len >= bufferSize) {
        return toString;
    }
    len = gu_strlcat(toString, " | ", bufferSize);
    if (len >= bufferSize) {
        return toString;
    }
    len += snprintf(toString + len, bufferSize - len, "%u", self->target_handstiffness);
    if (len >= bufferSize) {
        return toString;
    }
    len = gu_strlcat(toString, " | ", bufferSize);
    if (len >= bufferSize) {
        return toString;
    }
    len += snprintf(toString + len, bufferSize - len, "%u", self->target_shoulderpitch_active);
    if (len >= bufferSize) {
        return toString;
    }
    len = gu_strlcat(toString, " | ", bufferSize);
    if (len >= bufferSize) {
        return toString;
    }
    len += snprintf(toString + len, bufferSize - len, "%u", self->target_shoulderroll_active);
    if (len >= bufferSize) {
        return toString;
    }
    len = gu_strlcat(toString, " | ", bufferSize);
    if (len >= bufferSize) {
        return toString;
    }
    len += snprintf(toString + len, bufferSize - len, "%u", self->target_elbowroll_active);
    if (len >= bufferSize) {
        return toString;
    }
    len = gu_strlcat(toString, " | ", bufferSize);
    if (len >= bufferSize) {
        return toString;
    }
    len += snprintf(toString + len, bufferSize - len, "%u", self->target_elbowyaw_active);
    if (len >= bufferSize) {
        return toString;
    }
    len = gu_strlcat(toString, " | ", bufferSize);
    if (len >= bufferSize) {
        return toString;
    }
    len += snprintf(toString + len, bufferSize - len, "%u", self->target_wrist_active);
    if (len >= bufferSize) {
        return toString;
    }
    len = gu_strlcat(toString, " | ", bufferSize);
    if (len >= bufferSize) {
        return toString;
    }
    len += snprintf(toString + len, bufferSize - len, "%u", self->target_hand_active);
    if (len >= bufferSize) {
        return toString;
    }
    len = gu_strlcat(toString, " | ", bufferSize);
    if (len >= bufferSize) {
        return toString;
    }
    len += snprintf(toString + len, bufferSize - len, "%d", self->target_movement_time);
    if (len >= bufferSize) {
        return toString;
    }
    len = gu_strlcat(toString, " | ", bufferSize);
    if (len >= bufferSize) {
        return toString;
    }
    len += snprintf(toString + len, bufferSize - len, "%u", self->target_pliability);
    if (len >= bufferSize) {
        return toString;
    }
    len = gu_strlcat(toString, " | ", bufferSize);
    if (len >= bufferSize) {
        return toString;
    }
    len += snprintf(toString + len, bufferSize - len, "%u", self->target_arm_at_goal);
    if (len >= bufferSize) {
        return toString;
    }
    len = gu_strlcat(toString, " | ", bufferSize);
    if (len >= bufferSize) {
        return toString;
    }
    len += snprintf(toString + len, bufferSize - len, "%u", self->target_arm_stop);
    return toString;
}
#endif // WHITEBOARD_POSTER_STRING_CONVERSION

%c++

#ifdef WHITEBOARD_POSTER_STRING_CONVERSION
        /**
         *  Description function which prints values only
         *  (Spreadsheet friendly)
         */
        std::string valueDescription() {
#ifdef USE_WB_HAL_ARM_TARGET_C_CONVERSION
            char buffer[HAL_ARM_TARGET_DESC_BUFFER_SIZE+22];
            wb_hal_arm_target_value_description(this, buffer, sizeof(buffer));
            std::string descr = buffer;
            return descr;
#else
                std::stringstream ss;
                ss << static_cast<int>(target_shoulderpitch()) << " | "
                << static_cast<int>(target_shoulderroll()) << " | "
                << static_cast<int>(target_elbowroll()) << " | "
                << static_cast<int>(target_elbowyaw()) << " | "
                << static_cast<int>(target_wristyaw()) << " | "
                << static_cast<int>(target_hand()) << " | "
                << static_cast<int>(target_shoulderpitchstiffness()) << " | "
                << static_cast<int>(target_shoulderrollstiffness()) << " | "
                << static_cast<int>(target_elbowrollstiffness()) << " | "
                << static_cast<int>(target_elbowyawstiffness()) << " | "
                << static_cast<int>(target_wristyawstiffness()) << " | "
                << static_cast<int>(target_handstiffness()) << " | "
                << static_cast<int>(target_shoulderpitch_active()) << " | "
                << static_cast<int>(target_shoulderroll_active()) << " | "
                << static_cast<int>(target_elbowroll_active()) << " | "
                << static_cast<int>(target_elbowyaw_active()) << " | "
                << static_cast<int>(target_wrist_active()) << " | "
                << static_cast<int>(target_hand_active()) << " | "
                << static_cast<int>(target_movement_time()) << " | "
                << static_cast<int>(target_pliability()) << " | "
                << static_cast<int>(target_arm_at_goal()) << " | "
                << static_cast<int>(target_arm_stop());
                return ss.str();
            }
#endif /// USE_WB_HAL_ARM_TARGET_C_CONVERSION
#endif /// WHITEBOARD_POSTER_STRING_CONVERSION

//MARK: Arm - General
            /**
             *  Specify which arm this instance manages.
             *  Up to 256 arms are possible.
             *  Use prefedined macros LEFT_ARM and RIGHT_ARM for clarity.
             *
             *  @param  arm integer used to record which arm the object refers to.
             *
             */
            void tieToArm(uint8_t arm)
            {
                set_target_arm(arm);
            }

//MARK: Arm - Movements

            /**
             * move to position in radians over a given time
             * @param   shoulderpitch  down to up
             * @param   shoulderroll   out to in
             * @param   elbowroll      straight to bent
             * @param   elbowyaw       rolled right to rolled left
             * @param   wristyaw       rolled right to rolled left
             * @param   hand           closed to open
             * @param   time           elapsed time in mSec for the motion to complete.
             *
             */
            void goToWithTime_Rad(float shoulderpitch,
                                  float shoulderroll,
                                  float elbowroll,
                                  float elbowyaw,
                                  float wristyaw,
                                  float hand,
                                  int32_t time = INT_MAX)
            {
                setPose_Rad(shoulderpitch, shoulderroll,
                            elbowroll, elbowyaw,
                            wristyaw, hand);
                set_target_movement_time(time);
            }

            /**
             * move to position expressed in degrees over a given time
             * @param   shoulderpitch down to up
             * @param   shoulderroll  out to in
             * @param   elbowroll     straight to bent
             * @param   elbowyaw      rolled right to rolled left
             * @param   wristyaw      rolled right to rolled left
             * @param   hand          closed to open
             * @param   time          elapsed time in mSec for the motion to complete.
             *
             */
            void goToWithTime_Deg(float shoulderpitch,
                                  float shoulderroll,
                                  float elbowroll,
                                  float elbowyaw,
                                  float wristyaw,
                                  float hand,
                                  int32_t time = INT_MAX)
            {
                setPose_Deg(shoulderpitch, shoulderroll,
                            elbowroll, elbowyaw,
                            wristyaw, hand);
                set_target_movement_time(time);
            }

            /**
             * Command the arm to stop at its current
             * location and not act on motion commands
             * until ready() is called.
             *
             */
            void stop() {
                set_target_arm_stop(true);
            }


            /**
             * Set arm to ready state (Default)
             * The arm will act on motion commands.
             *
             */
            void ready() {
                set_target_arm_stop(false);
            }


            /**
             *  Arm at Goal Setter
             *      Clients/Machines should not use this method.
             *
             *  Arm arrived at goal pose.
             *  Only set in the status message by naoqiinterface when the arm has reached the goal pose.
             *
             *  @param  goalReached  the arm has reached the goal (true/false)
             *
             */
            void isAtGoal(bool goalReached)
            {
                set_target_arm_at_goal(goalReached);
            }

            /**
             *  Arm at Goal Getter
             *      Clients/Machines should use this getter to test if the DCM
             *      has reported that the arm has reached its goal pose.
             *
             *  Is the arm at the goal pose?
             *  Naoqi Interface sets this true when the arm reaches the goal
             *  pose asked for in the previous control message.
             *
             *  @return     bool    whether the arm is at the goal location or not.
             *
             */
            bool atGoal()
            {
                return target_arm_at_goal();
            }

            /**
             *  Client side test to determine if arm is at the target location, allowing for specified tolerances.
             *  The method tests if the pose 'status' is within 'tolerance' of 'this' target
             *  location, allowing for a specified tolerance.
             *
             *  'this' object contains the target pose settings.
             *
             *  @param  status      HalArmTarget object which contains actual pose settings reported by the robot's sensors.
             *  @param  tolerance   HalArmTarget object whose pose settings specify the tolerance for each joint/gripper
             *  @return bool        whether or not the status is within range of the target location.
             *
             */
            bool atTargetLocation(HalArmTarget status, HalArmTarget tolerance)
            {
                int16_t shoulderpitchMargin = static_cast<int16_t>(abs(target_shoulderpitch() - status.target_shoulderpitch()));
                int16_t shoulderrollMargin = static_cast<int16_t>(abs(target_shoulderroll() - status.target_shoulderroll()));
                int16_t elbowrollMargin = static_cast<int16_t>(abs(target_elbowroll() - status.target_elbowroll()));
                int16_t elbowyawMargin = static_cast<int16_t>(abs(target_elbowyaw() - status.target_elbowyaw()));
                //#ifdef NAO_V3
                //    int16_t wristyawMargin = static_cast<int16_t>(abs(target_wristyaw - status.target_wristyaw()));
                //    uint8_t handMargin = static_cast<uint8_t>(abs(target_hand() - status.target_hand()));
                if (   (shoulderpitchMargin <= tolerance.target_shoulderpitch())
                    && (shoulderrollMargin <= tolerance.target_shoulderroll())
                    && (elbowrollMargin <= tolerance.target_elbowroll())
                    && (elbowyawMargin <= tolerance.target_elbowyaw())
                    //#ifdef NAO_V3
                    //        && (wristyawMargin <= tolerance.target_wristyaw())
                    //        && (handMargin <= tolerance.target_hand())
                    )
                {
                    return true;
                }
                return false;
            }

//MARK: Arm - Pose

            /**
             * Set Pose in radians
             * @param   shoulderpitch  down to up
             * @param   shoulderroll   out to in
             * @param   elbowroll      straight to bent
             * @param   elbowyaw       rolled right to rolled left
             * @param   wristyaw       rolled right to rolled left
             * @param   hand           closed to open.
             *
             */
            void setPose_Rad(float shoulderpitch,
                             float shoulderroll,
                             float elbowroll,
                             float elbowyaw,
                             float wristyaw,
                             float hand)
            {
                set_shoulderpitch_RAD(shoulderpitch);
                set_shoulderroll_RAD(shoulderroll);
                set_elbowroll_RAD(elbowroll);
                set_elbowyaw_RAD(elbowyaw);
                set_wristyaw_RAD(wristyaw);
                set_hand(hand);
            }

            /**
             * Set Pose in degrees
             * @param   shoulderpitch down to up
             * @param   shoulderroll  out to in
             * @param   elbowroll     straight to bent
             * @param   elbowyaw      rolled right to rolled left
             * @param   wristyaw      rolled right to rolled left
             * @param   hand          closed to open.
             *
             */
            void setPose_Deg(float shoulderpitch,
                             float shoulderroll,
                             float elbowroll,
                             float elbowyaw,
                             float wristyaw,
                             float hand)
            {
                set_shoulderpitch_DEG(shoulderpitch);
                set_shoulderroll_DEG(shoulderroll);
                set_elbowroll_DEG(elbowroll);
                set_elbowyaw_DEG(elbowyaw);
                set_wristyaw_DEG(wristyaw);
                set_hand(hand);
            }


            /**
             *  Convenience function to mirror arm settings about the XZ plane from one HalArmTarget object to another.
             *
             *  @param  other    HalArmTarget object to be mirrored.
             *
             */
            void mirrorArm(const HalArmTarget &other)
            {
                // Roll and Yaw angles need to be mirrored, others just copied.
                set_target_shoulderpitch(other.target_shoulderpitch());
                set_target_shoulderroll(-other.target_shoulderroll());
                set_target_elbowroll(-other.target_elbowroll());
                set_target_elbowyaw(-other.target_elbowyaw());
                set_target_wristyaw(-other.target_wristyaw());
                set_target_hand(other.target_hand());
                set_target_shoulderpitchstiffness(other.target_shoulderpitchstiffness());
                set_target_shoulderrollstiffness(other.target_shoulderrollstiffness());
                set_target_elbowrollstiffness(other.target_elbowrollstiffness());
                set_target_elbowyawstiffness(other.target_elbowyawstiffness());
                set_target_wristyawstiffness(other.target_wristyawstiffness());
                set_target_handstiffness(other.target_handstiffness());
                set_target_shoulderpitch_active(other.target_shoulderpitch_active());
                set_target_shoulderroll_active(other.target_shoulderroll_active());
                set_target_elbowroll_active(other.target_elbowroll_active());
                set_target_elbowyaw_active(other.target_elbowyaw_active());
                set_target_wrist_active(other.target_wrist_active());
                set_target_hand_active(other.target_hand_active());
                set_target_movement_time(other.target_movement_time());
                set_target_pliability(other.target_pliability());
            }

            /**
             *  Convenience function to copy pose settings from one HalArmTarget object to another.
             *
             *  @param  other    HalArmTarget object from which to copy pose settings from.
             *
             */
            void copyPose(const HalArmTarget &other)
            {
                set_target_shoulderpitch(other.target_shoulderpitch());
                set_target_shoulderroll(other.target_shoulderroll());
                set_target_elbowroll(other.target_elbowroll());
                set_target_elbowyaw(other.target_elbowyaw());
                set_target_wristyaw(other.target_wristyaw());
                set_target_hand(other.target_hand());
            }

            /**
             *  Convenience function to mirror pose settings about the XZ plane from one HalArmTarget object to another.
             *
             *  @param  other    HalArmTarget object whose pose settings are to be mirrored.
             *
             */
            void mirrorPose(const HalArmTarget &other)
            {
                set_target_shoulderpitch(other.target_shoulderpitch());
                set_target_shoulderroll(-other.target_shoulderroll());
                set_target_elbowroll(-other.target_elbowroll());
                set_target_elbowyaw(-other.target_elbowyaw());
                set_target_wristyaw(-other.target_wristyaw());
                set_target_hand(other.target_hand());
            }

            /**
             *  Tests if this HalArmTarget object has the same pose settings as the other HalArmTarget object.
             *      NOTE this does not take into account mirroring about the XZ plane.
             *
             *  @param  other   HalArmTarget object whose pose settings are being compared.
             *  @return bool    whether the two objects have the same pose or not.
             *
             */
            bool hasSamePose(const HalArmTarget &other)
            {
                if (
                    target_shoulderpitch() == other.target_shoulderpitch()
                    && target_shoulderroll() == other.target_shoulderroll()
                    && target_elbowroll() == other.target_elbowroll()
                    && target_elbowyaw() == other.target_elbowyaw()
                    && target_wristyaw() == other.target_wristyaw()
                    && target_hand() == other.target_hand()
                    )
                {
                    return  true;
                }
                return false;
            }

            /**
             *  Tests if this HalArmTarget object has the same mirrored pose settings as the other HalArmTarget object.
             *      NOTE this method takes into account mirroring about the XZ plane.
             *
             *  @param  other   HalArmTarget object whose pose settings are being compared.
             *  @return bool    whether the two objects have the same pose or not.
             *
             */
            bool hasSameMirroredPose(const HalArmTarget &other)
            {
                if (
                    target_shoulderpitch() == other.target_shoulderpitch()
                    && target_shoulderroll() == -other.target_shoulderroll()
                    && target_elbowroll() == -other.target_elbowroll()
                    && target_elbowyaw() == -other.target_elbowyaw()
                    && target_wristyaw() == -other.target_wristyaw()
                    && target_hand() == other.target_hand()
                    )
                {
                    return  true;
                }
                return false;
            }

//MARK: Arm - Stiffness

            /**
             *  Convenience function to set the stiffness
             *  of all the arm's joints to the maximum (1.0f).
             *
             */
            void setArmStiffnessMax()
            {
                set_shoulderpitchstiffness(1.0f);
                set_shoulderrollstiffness(1.0f);
                set_elbowrollstiffness(1.0f);
                set_elbowyawstiffness(1.0f);
                set_wristyawstiffness(1.0f);
                set_handstiffness(1.0f);
            }

            /**
             *  Convenience function to set the stiffness
             *  of all the arm's joints to what Aldebaran
             *  considers 'normal' (0.6f).
             *
             */
            void setArmStiffnessNormal()
            {
                set_shoulderpitchstiffness(0.6f);
                set_shoulderrollstiffness(0.6f);
                set_elbowrollstiffness(0.6f);
                set_elbowyawstiffness(0.6f);
                set_wristyawstiffness(0.6f);
                set_handstiffness(0.6f);
            }

            /**
             *  Convenience function to set uniform stiffness
             *  on all arm joints to a custom value.
             *
             *  @param stiffness float Stiffness setting between 0.0 and 1.0 (float).
             *
             */
            void setArmStiffness(float stiffness)
            {
                if ((stiffness <= 1.0f) && (stiffness >=0.0f)) {
                    set_shoulderpitchstiffness(stiffness);
                    set_shoulderrollstiffness(stiffness);
                    set_elbowrollstiffness(stiffness);
                    set_elbowyawstiffness(stiffness);
                    set_wristyawstiffness(stiffness);
                    set_handstiffness(stiffness);
                }
            }

            /**
             *  Convenience function to turn off stiffness
             *  in all the arm's joints (0.0f).
             *
             */
            void setArmStiffnessOff()
            {
                set_shoulderpitchstiffness(0.0f);
                set_shoulderrollstiffness(0.0f);
                set_elbowrollstiffness(0.0f);
                set_elbowyawstiffness(0.0f);
                set_wristyawstiffness(0.0f);
                set_handstiffness(0.0f);
            }


            /**
             *  Convenience function to copy stiffness settings from one HalArmTarget object to another.
             *
             *  @param  other    HalArmTarget object from which to copy stiffness settings.
             *
             */
            void copyStiffness(const HalArmTarget &other)
            {
                target_shoulderpitchstiffness() = other.target_shoulderpitchstiffness();
                target_shoulderrollstiffness() = other.target_shoulderrollstiffness();
                target_elbowrollstiffness() = other.target_elbowrollstiffness();
                target_elbowyawstiffness() = other.target_elbowyawstiffness();
                target_wristyawstiffness() = other.target_wristyawstiffness();
                target_handstiffness() = other.target_handstiffness();
            }



            /**
             *  Tests if this HalArmTarget object has the same stiffness settings as the other HalArmTarget object.
             *
             *  @param  other   HalArmTarget object whose stiffness settings are being compared.
             *  @return bool    whether the two objects have the same stiffness or not.
             *
             */
            bool hasSameStiffness(const HalArmTarget &other)
            {
                if (
                    target_shoulderpitchstiffness() == other.target_shoulderpitchstiffness()
                    && target_shoulderrollstiffness() == other.target_shoulderrollstiffness()
                    && target_elbowrollstiffness() == other.target_elbowrollstiffness()
                    && target_elbowyawstiffness() == other.target_elbowyawstiffness()
                    && target_wristyawstiffness() == other.target_wristyawstiffness()
                    && target_handstiffness() == other.target_handstiffness()
                   )
                {
                    return  true;
                }
                return false;
            }

//MARK: Arm - Pliability

            /**
             *  Set arm to be Active (DEDAULT DCM state)
             *  The arm is active and manual movements will be resisted, be careful when the stiffness is set high.
             *  Once the applied force is removed, the arm will return to its previous location.
             *  Be careful using this with high stiffness settings (which vary per joint), as the gears will be stripped.
             *
             *  NOTE:  This is the default DCM mode.
             *
             */
            void setArmActive()
            {
                set_target_shoulderpitch_active(true);
                set_target_shoulderroll_active(true);
                set_target_elbowroll_active(true);
                set_target_elbowyaw_active(true);
                set_target_wrist_active(true);
                set_target_hand_active(true);
            }

            /**
             *  Set arm to be Passive
             *  Manually moving the arm causes the arm to remain in the new position.
             *  Be careful using this with high stiffness and pliability settings (which vary per joint).
             *
             *  NOTE:  This is achieved by telling the DCM to move the arm to the displaced
             *         position each DCM cyle.  Thus the arm tracks the applied force.
             *         The 'pliability' setting reduces the update rate, thus making the arm stiffer. At
             *         higher pliability settings, the movement will become noticably stepped.
             *
             */
            void setArmPassive()
            {
                set_target_shoulderpitch_active(false);
                set_target_shoulderroll_active(false);
                set_target_elbowroll_active(false);
                set_target_elbowyaw_active(false);
                set_target_wrist_active(false);
                set_target_hand_active(false);
            }


            /**
             *  Individually set the active/passive state of each joint.
             *  See Arm_Active() and Arm_Passive() methods for an explanation of the Active/Passive effect.
             *
             */
            void setArmPliability(bool shoulderpitch, bool shoulderroll, bool elbowroll,
                                bool elbowyaw, bool wristyaw, bool hand)
            {
                set_target_shoulderpitch_active(shoulderpitch);
                set_target_shoulderroll_active(shoulderroll);
                set_target_elbowroll_active(elbowroll);
                set_target_elbowyaw_active(elbowyaw);
                set_target_wrist_active(wristyaw);
                set_target_hand_active(hand);
            }

            /**
             *  Are any of the arm's joints set to passive
             *
             */
            bool isArmPassive() {
                return !target_shoulderpitch_active() || !target_shoulderroll_active() || !target_elbowroll_active() || !target_elbowyaw_active() || !target_wrist_active() || !target_hand_active();
            }

            /**
             *  Are all of the arm's joints set to passive
             *
             */
            bool isArmAllPassive() {
                return !target_shoulderpitch_active() && !target_shoulderroll_active() && !target_elbowroll_active() && !target_elbowyaw_active() && !target_wrist_active() && !target_hand_active();
            }

            /**
             *  Are all of the arm's joints set to active
             *
             */
            bool isArmAllActive() {
                return target_shoulderpitch_active() && target_shoulderroll_active() && target_elbowroll_active() && target_elbowyaw_active() && target_wrist_active() && target_hand_active();
            }

//MARK: CUSTOM SETTERS (Converting floats into Integer representations)
/// Movement Setters (Degrees)
            void set_shoulderpitch_DEG(float setting) {
                set_target_shoulderpitch(static_cast<int16_t>(setting * 10.0f));
            }

            void set_shoulderroll_DEG(float setting) {
                set_target_shoulderroll(static_cast<int16_t>(setting * 10.0f));
            }

            void set_elbowroll_DEG(float setting) {
                set_target_elbowroll(static_cast<int16_t>(setting * 10.0f));
            }

            void set_elbowyaw_DEG(float setting) {
                set_target_elbowyaw(static_cast<int16_t>(setting * 10.0f));
            }

            void set_wristyaw_DEG(float setting) {
                set_target_wristyaw(static_cast<int16_t>(setting * 10.0f));
            }

/// Movement Setters (Radians)
            void set_shoulderpitch_RAD(float setting) {
                set_target_shoulderpitch(static_cast<int16_t>(setting* DEG_OVER_RAD_10));
            }

            void set_shoulderroll_RAD(float setting) {
                set_target_shoulderroll(static_cast<int16_t>(setting * DEG_OVER_RAD_10));
            }

            void set_elbowroll_RAD(float setting) {
                set_target_elbowroll(static_cast<int16_t>(setting * DEG_OVER_RAD_10));
            }

            void set_elbowyaw_RAD(float setting) {
                set_target_elbowyaw(static_cast<int16_t>(setting * DEG_OVER_RAD_10));
            }

            void set_wristyaw_RAD(float setting) {
                set_target_wristyaw(static_cast<int16_t>(setting * DEG_OVER_RAD_10));
            }

/// Hand Movement Setter
            void set_hand(float setting) {
                set_target_hand(static_cast<uint8_t>(setting * 100.0f));
            }

/// Stiffness Setters
            void set_shoulderpitchstiffness(float setting) {
                set_target_shoulderpitchstiffness(static_cast<uint8_t>(setting * 100.0f));
            }

            void set_shoulderrollstiffness(float setting) {
                set_target_shoulderrollstiffness(static_cast<uint8_t>(setting * 100.0f));
            }

            void set_elbowrollstiffness(float setting) {
                set_target_elbowrollstiffness(static_cast<uint8_t>(setting * 100.0f));
            }

            void set_elbowyawstiffness(float setting) {
                set_target_elbowyawstiffness(static_cast<uint8_t>(setting * 100.0f));
            }

            void set_wristyawstiffness(float setting) {
                set_target_wristyawstiffness(static_cast<uint8_t>(setting * 100.0f));
            }

            void set_handstiffness(float setting) {
                set_target_handstiffness(static_cast<uint8_t>(setting * 100.0f));
            }


///// Duration Setter
//            void set_movement_time(int32_t time) {
//                set_target_movement_time(time);
//            }

//MARK: CUSTOM GETTERS (Converting Integer representations back to floats)
/// Movement Getters (Degrees)
            float get_shoulderpitch_DEG() {
                return static_cast<float>(target_shoulderpitch() * 0.1f);
            }

            float get_shoulderroll_DEG() {
                return static_cast<float>(target_shoulderroll() * 0.1f);
            }

            float get_elbowroll_DEG() {
                return static_cast<float>(target_elbowroll() * 0.1f);
            }

            float get_elbowyaw_DEG() {
                return static_cast<float>(target_elbowyaw() * 0.1f);
            }

            float get_wristyaw_DEG() {
                return static_cast<float>(target_wristyaw() * 0.1f);
            }

/// Movement Getters (Radians)
            float get_shoulderpitch_RAD() {
                return static_cast<float>(target_shoulderpitch()) * RAD_OVER_DEG_10;
            }

            float get_shoulderroll_RAD() {
                return static_cast<float>(target_shoulderroll()) * RAD_OVER_DEG_10;
            }

            float get_elbowroll_RAD() {
                return static_cast<float>(target_elbowroll()) * RAD_OVER_DEG_10;
            }

            float get_elbowyaw_RAD() {
                return static_cast<float>(target_elbowyaw()) * RAD_OVER_DEG_10;
            }

            float get_wristyaw_RAD() {
                return static_cast<float>(target_wristyaw()) * RAD_OVER_DEG_10;
            }

/// Hand Movement Getter
            float get_hand() {
                return static_cast<float>(target_hand()) * 0.01f;
            }

/// Stiffness Getters
            float get_shoulderpitchstiffness() {
                return static_cast<float>(target_shoulderpitchstiffness()) * 0.01f;
            }

            float get_shoulderrollstiffness() {
                return static_cast<float>(target_shoulderrollstiffness()) * 0.01f;
            }

            float get_elbowrollstiffness() {
                return static_cast<float>(target_elbowrollstiffness()) * 0.01f;
            }

            float get_elbowyawstiffness() {
                return static_cast<float>(target_elbowyawstiffness()) * 0.01f;
            }

            float get_wristyawstiffness() {
                return static_cast<float>(target_wristyawstiffness()) * 0.01f;
            }

            float get_handstiffness() {
                return static_cast<float>(target_handstiffness()) * 0.01f;
            }


-comment
Classgenerator version