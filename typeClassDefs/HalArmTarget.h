/*
 * file HalArmTarget.h
 *
 * This file was generated by classgenerator from hal_arm_target.gen.
 * DO NOT CHANGE MANUALLY!
 *
 * Copyright Â© 2020 Dimitri Joukoff. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials
 *    provided with the distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgement:
 *
 *        This product includes software developed by Dimitri Joukoff.
 *
 * 4. Neither the name of the author nor the names of contributors
 *    may be used to endorse or promote products derived from this
 *    software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
 * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * -----------------------------------------------------------------------
 * This program is free software; you can redistribute it and/or
 * modify it under the above terms or under the terms of the GNU
 * General Public License as published by the Free Software Foundation;
 * either version 2 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, see http://www.gnu.org/licenses/
 * or write to the Free Software Foundation, Inc., 51 Franklin Street,
 * Fifth Floor, Boston, MA  02110-1301, USA.
 *
 */

#ifndef HalArmTarget_DEFINED
#define HalArmTarget_DEFINED

#ifdef WHITEBOARD_POSTER_STRING_CONVERSION
#include <cstdlib>
#include <string.h>
#include <sstream>
#endif

#include <gu_util.h>
#include "wb_hal_arm_target.h"

namespace guWhiteboard {

    /**
     * Provides a C++ wrapper around `wb_hal_arm_target`.
     */
    class HalArmTarget: public wb_hal_arm_target {

    private:

        /**
         * Set the members of the class.
         */
        void init(int32_t t_target_movement_time = INT_MAX, int16_t t_target_shoulderpitch = 0, int16_t t_target_shoulderroll = 0, int16_t t_target_elbowroll = 0, int16_t t_target_elbowyaw = 0, int16_t t_target_wristyaw = 0, uint8_t t_target_arm = LEFT_ARM, uint8_t t_target_hand = 0, uint8_t t_target_shoulderpitchstiffness = 0, uint8_t t_target_shoulderrollstiffness = 0, uint8_t t_target_elbowrollstiffness = 0, uint8_t t_target_elbowyawstiffness = 0, uint8_t t_target_wristyawstiffness = 0, uint8_t t_target_handstiffness = 0, uint8_t t_target_pliability = 0, unsigned int t_target_shoulderpitch_active = true, unsigned int t_target_shoulderroll_active = true, unsigned int t_target_elbowroll_active = true, unsigned int t_target_elbowyaw_active = true, unsigned int t_target_wrist_active = true, unsigned int t_target_hand_active = true, unsigned int t_target_arm_at_goal = false, unsigned int t_target_arm_stop = false) {
            set_target_movement_time(t_target_movement_time);
            set_target_shoulderpitch(t_target_shoulderpitch);
            set_target_shoulderroll(t_target_shoulderroll);
            set_target_elbowroll(t_target_elbowroll);
            set_target_elbowyaw(t_target_elbowyaw);
            set_target_wristyaw(t_target_wristyaw);
            set_target_arm(t_target_arm);
            set_target_hand(t_target_hand);
            set_target_shoulderpitchstiffness(t_target_shoulderpitchstiffness);
            set_target_shoulderrollstiffness(t_target_shoulderrollstiffness);
            set_target_elbowrollstiffness(t_target_elbowrollstiffness);
            set_target_elbowyawstiffness(t_target_elbowyawstiffness);
            set_target_wristyawstiffness(t_target_wristyawstiffness);
            set_target_handstiffness(t_target_handstiffness);
            set_target_pliability(t_target_pliability);
            set_target_shoulderpitch_active(t_target_shoulderpitch_active);
            set_target_shoulderroll_active(t_target_shoulderroll_active);
            set_target_elbowroll_active(t_target_elbowroll_active);
            set_target_elbowyaw_active(t_target_elbowyaw_active);
            set_target_wrist_active(t_target_wrist_active);
            set_target_hand_active(t_target_hand_active);
            set_target_arm_at_goal(t_target_arm_at_goal);
            set_target_arm_stop(t_target_arm_stop);
        }

    public:

        /**
         * Create a new `HalArmTarget`.
         */
        HalArmTarget(int32_t t_target_movement_time = INT_MAX, int16_t t_target_shoulderpitch = 0, int16_t t_target_shoulderroll = 0, int16_t t_target_elbowroll = 0, int16_t t_target_elbowyaw = 0, int16_t t_target_wristyaw = 0, uint8_t t_target_arm = LEFT_ARM, uint8_t t_target_hand = 0, uint8_t t_target_shoulderpitchstiffness = 0, uint8_t t_target_shoulderrollstiffness = 0, uint8_t t_target_elbowrollstiffness = 0, uint8_t t_target_elbowyawstiffness = 0, uint8_t t_target_wristyawstiffness = 0, uint8_t t_target_handstiffness = 0, uint8_t t_target_pliability = 0, unsigned int t_target_shoulderpitch_active = true, unsigned int t_target_shoulderroll_active = true, unsigned int t_target_elbowroll_active = true, unsigned int t_target_elbowyaw_active = true, unsigned int t_target_wrist_active = true, unsigned int t_target_hand_active = true, unsigned int t_target_arm_at_goal = false, unsigned int t_target_arm_stop = false) {
            this->init(t_target_movement_time, t_target_shoulderpitch, t_target_shoulderroll, t_target_elbowroll, t_target_elbowyaw, t_target_wristyaw, t_target_arm, t_target_hand, t_target_shoulderpitchstiffness, t_target_shoulderrollstiffness, t_target_elbowrollstiffness, t_target_elbowyawstiffness, t_target_wristyawstiffness, t_target_handstiffness, t_target_pliability, t_target_shoulderpitch_active, t_target_shoulderroll_active, t_target_elbowroll_active, t_target_elbowyaw_active, t_target_wrist_active, t_target_hand_active, t_target_arm_at_goal, t_target_arm_stop);
        }

        /**
         * Copy Constructor.
         */
        HalArmTarget(const HalArmTarget &t_other): wb_hal_arm_target() {
            this->init(t_other.target_movement_time(), t_other.target_shoulderpitch(), t_other.target_shoulderroll(), t_other.target_elbowroll(), t_other.target_elbowyaw(), t_other.target_wristyaw(), t_other.target_arm(), t_other.target_hand(), t_other.target_shoulderpitchstiffness(), t_other.target_shoulderrollstiffness(), t_other.target_elbowrollstiffness(), t_other.target_elbowyawstiffness(), t_other.target_wristyawstiffness(), t_other.target_handstiffness(), t_other.target_pliability(), t_other.target_shoulderpitch_active(), t_other.target_shoulderroll_active(), t_other.target_elbowroll_active(), t_other.target_elbowyaw_active(), t_other.target_wrist_active(), t_other.target_hand_active(), t_other.target_arm_at_goal(), t_other.target_arm_stop());
        }

        /**
         * Copy Constructor.
         */
        HalArmTarget(const struct wb_hal_arm_target &t_other): wb_hal_arm_target() {
            this->init(t_other.target_movement_time, t_other.target_shoulderpitch, t_other.target_shoulderroll, t_other.target_elbowroll, t_other.target_elbowyaw, t_other.target_wristyaw, t_other.target_arm, t_other.target_hand, t_other.target_shoulderpitchstiffness, t_other.target_shoulderrollstiffness, t_other.target_elbowrollstiffness, t_other.target_elbowyawstiffness, t_other.target_wristyawstiffness, t_other.target_handstiffness, t_other.target_pliability, t_other.target_shoulderpitch_active, t_other.target_shoulderroll_active, t_other.target_elbowroll_active, t_other.target_elbowyaw_active, t_other.target_wrist_active, t_other.target_hand_active, t_other.target_arm_at_goal, t_other.target_arm_stop);
        }

        /**
         * Copy Assignment Operator.
         */
        HalArmTarget &operator = (const HalArmTarget &t_other) {
            this->init(t_other.target_movement_time(), t_other.target_shoulderpitch(), t_other.target_shoulderroll(), t_other.target_elbowroll(), t_other.target_elbowyaw(), t_other.target_wristyaw(), t_other.target_arm(), t_other.target_hand(), t_other.target_shoulderpitchstiffness(), t_other.target_shoulderrollstiffness(), t_other.target_elbowrollstiffness(), t_other.target_elbowyawstiffness(), t_other.target_wristyawstiffness(), t_other.target_handstiffness(), t_other.target_pliability(), t_other.target_shoulderpitch_active(), t_other.target_shoulderroll_active(), t_other.target_elbowroll_active(), t_other.target_elbowyaw_active(), t_other.target_wrist_active(), t_other.target_hand_active(), t_other.target_arm_at_goal(), t_other.target_arm_stop());
            return *this;
        }

        /**
         * Copy Assignment Operator.
         */
        HalArmTarget &operator = (const struct wb_hal_arm_target &t_other) {
            this->init(t_other.target_movement_time, t_other.target_shoulderpitch, t_other.target_shoulderroll, t_other.target_elbowroll, t_other.target_elbowyaw, t_other.target_wristyaw, t_other.target_arm, t_other.target_hand, t_other.target_shoulderpitchstiffness, t_other.target_shoulderrollstiffness, t_other.target_elbowrollstiffness, t_other.target_elbowyawstiffness, t_other.target_wristyawstiffness, t_other.target_handstiffness, t_other.target_pliability, t_other.target_shoulderpitch_active, t_other.target_shoulderroll_active, t_other.target_elbowroll_active, t_other.target_elbowyaw_active, t_other.target_wrist_active, t_other.target_hand_active, t_other.target_arm_at_goal, t_other.target_arm_stop);
            return *this;
        }

        bool operator ==(const HalArmTarget &t_other) const
        {
            return target_movement_time() == t_other.target_movement_time()
                && target_shoulderpitch() == t_other.target_shoulderpitch()
                && target_shoulderroll() == t_other.target_shoulderroll()
                && target_elbowroll() == t_other.target_elbowroll()
                && target_elbowyaw() == t_other.target_elbowyaw()
                && target_wristyaw() == t_other.target_wristyaw()
                && target_arm() == t_other.target_arm()
                && target_hand() == t_other.target_hand()
                && target_shoulderpitchstiffness() == t_other.target_shoulderpitchstiffness()
                && target_shoulderrollstiffness() == t_other.target_shoulderrollstiffness()
                && target_elbowrollstiffness() == t_other.target_elbowrollstiffness()
                && target_elbowyawstiffness() == t_other.target_elbowyawstiffness()
                && target_wristyawstiffness() == t_other.target_wristyawstiffness()
                && target_handstiffness() == t_other.target_handstiffness()
                && target_pliability() == t_other.target_pliability()
                && target_shoulderpitch_active() == t_other.target_shoulderpitch_active()
                && target_shoulderroll_active() == t_other.target_shoulderroll_active()
                && target_elbowroll_active() == t_other.target_elbowroll_active()
                && target_elbowyaw_active() == t_other.target_elbowyaw_active()
                && target_wrist_active() == t_other.target_wrist_active()
                && target_hand_active() == t_other.target_hand_active()
                && target_arm_at_goal() == t_other.target_arm_at_goal()
                && target_arm_stop() == t_other.target_arm_stop();
        }

        bool operator !=(const HalArmTarget &t_other) const
        {
            return !(*this == t_other);
        }

        bool operator ==(const wb_hal_arm_target &t_other) const
        {
            return *this == HalArmTarget(t_other);
        }

        bool operator !=(const wb_hal_arm_target &t_other) const
        {
            return !(*this == t_other);
        }

        int32_t target_movement_time() const
        {
            return wb_hal_arm_target::target_movement_time;
        }

        void set_target_movement_time(const int32_t &t_newValue)
        {
            wb_hal_arm_target::target_movement_time = t_newValue;
        }

        int16_t target_shoulderpitch() const
        {
            return wb_hal_arm_target::target_shoulderpitch;
        }

        void set_target_shoulderpitch(const int16_t &t_newValue)
        {
            wb_hal_arm_target::target_shoulderpitch = t_newValue;
        }

        int16_t target_shoulderroll() const
        {
            return wb_hal_arm_target::target_shoulderroll;
        }

        void set_target_shoulderroll(const int16_t &t_newValue)
        {
            wb_hal_arm_target::target_shoulderroll = t_newValue;
        }

        int16_t target_elbowroll() const
        {
            return wb_hal_arm_target::target_elbowroll;
        }

        void set_target_elbowroll(const int16_t &t_newValue)
        {
            wb_hal_arm_target::target_elbowroll = t_newValue;
        }

        int16_t target_elbowyaw() const
        {
            return wb_hal_arm_target::target_elbowyaw;
        }

        void set_target_elbowyaw(const int16_t &t_newValue)
        {
            wb_hal_arm_target::target_elbowyaw = t_newValue;
        }

        int16_t target_wristyaw() const
        {
            return wb_hal_arm_target::target_wristyaw;
        }

        void set_target_wristyaw(const int16_t &t_newValue)
        {
            wb_hal_arm_target::target_wristyaw = t_newValue;
        }

        uint8_t target_arm() const
        {
            return wb_hal_arm_target::target_arm;
        }

        void set_target_arm(const uint8_t &t_newValue)
        {
            wb_hal_arm_target::target_arm = t_newValue;
        }

        uint8_t target_hand() const
        {
            return wb_hal_arm_target::target_hand;
        }

        void set_target_hand(const uint8_t &t_newValue)
        {
            wb_hal_arm_target::target_hand = t_newValue;
        }

        uint8_t target_shoulderpitchstiffness() const
        {
            return wb_hal_arm_target::target_shoulderpitchstiffness;
        }

        void set_target_shoulderpitchstiffness(const uint8_t &t_newValue)
        {
            wb_hal_arm_target::target_shoulderpitchstiffness = t_newValue;
        }

        uint8_t target_shoulderrollstiffness() const
        {
            return wb_hal_arm_target::target_shoulderrollstiffness;
        }

        void set_target_shoulderrollstiffness(const uint8_t &t_newValue)
        {
            wb_hal_arm_target::target_shoulderrollstiffness = t_newValue;
        }

        uint8_t target_elbowrollstiffness() const
        {
            return wb_hal_arm_target::target_elbowrollstiffness;
        }

        void set_target_elbowrollstiffness(const uint8_t &t_newValue)
        {
            wb_hal_arm_target::target_elbowrollstiffness = t_newValue;
        }

        uint8_t target_elbowyawstiffness() const
        {
            return wb_hal_arm_target::target_elbowyawstiffness;
        }

        void set_target_elbowyawstiffness(const uint8_t &t_newValue)
        {
            wb_hal_arm_target::target_elbowyawstiffness = t_newValue;
        }

        uint8_t target_wristyawstiffness() const
        {
            return wb_hal_arm_target::target_wristyawstiffness;
        }

        void set_target_wristyawstiffness(const uint8_t &t_newValue)
        {
            wb_hal_arm_target::target_wristyawstiffness = t_newValue;
        }

        uint8_t target_handstiffness() const
        {
            return wb_hal_arm_target::target_handstiffness;
        }

        void set_target_handstiffness(const uint8_t &t_newValue)
        {
            wb_hal_arm_target::target_handstiffness = t_newValue;
        }

        uint8_t target_pliability() const
        {
            return wb_hal_arm_target::target_pliability;
        }

        void set_target_pliability(const uint8_t &t_newValue)
        {
            wb_hal_arm_target::target_pliability = t_newValue;
        }

        unsigned int target_shoulderpitch_active() const
        {
            return wb_hal_arm_target::target_shoulderpitch_active;
        }

        void set_target_shoulderpitch_active(const unsigned int &t_newValue)
        {
            wb_hal_arm_target::target_shoulderpitch_active = t_newValue;
        }

        unsigned int target_shoulderroll_active() const
        {
            return wb_hal_arm_target::target_shoulderroll_active;
        }

        void set_target_shoulderroll_active(const unsigned int &t_newValue)
        {
            wb_hal_arm_target::target_shoulderroll_active = t_newValue;
        }

        unsigned int target_elbowroll_active() const
        {
            return wb_hal_arm_target::target_elbowroll_active;
        }

        void set_target_elbowroll_active(const unsigned int &t_newValue)
        {
            wb_hal_arm_target::target_elbowroll_active = t_newValue;
        }

        unsigned int target_elbowyaw_active() const
        {
            return wb_hal_arm_target::target_elbowyaw_active;
        }

        void set_target_elbowyaw_active(const unsigned int &t_newValue)
        {
            wb_hal_arm_target::target_elbowyaw_active = t_newValue;
        }

        unsigned int target_wrist_active() const
        {
            return wb_hal_arm_target::target_wrist_active;
        }

        void set_target_wrist_active(const unsigned int &t_newValue)
        {
            wb_hal_arm_target::target_wrist_active = t_newValue;
        }

        unsigned int target_hand_active() const
        {
            return wb_hal_arm_target::target_hand_active;
        }

        void set_target_hand_active(const unsigned int &t_newValue)
        {
            wb_hal_arm_target::target_hand_active = t_newValue;
        }

        unsigned int target_arm_at_goal() const
        {
            return wb_hal_arm_target::target_arm_at_goal;
        }

        void set_target_arm_at_goal(const unsigned int &t_newValue)
        {
            wb_hal_arm_target::target_arm_at_goal = t_newValue;
        }

        unsigned int target_arm_stop() const
        {
            return wb_hal_arm_target::target_arm_stop;
        }

        void set_target_arm_stop(const unsigned int &t_newValue)
        {
            wb_hal_arm_target::target_arm_stop = t_newValue;
        }

#ifdef WHITEBOARD_POSTER_STRING_CONVERSION
        /**
         * String Constructor.
         */
        HalArmTarget(const std::string &t_str) {
            this->init();
            this->from_string(t_str);
        }

        std::string description() {
#ifdef USE_WB_HAL_ARM_TARGET_C_CONVERSION
            char buffer[HAL_ARM_TARGET_DESC_BUFFER_SIZE];
            wb_hal_arm_target_description(this, buffer, sizeof(buffer));
            std::string descr = buffer;
            return descr;
#else
            std::ostringstream ss;
            ss << "target_movement_time=" << static_cast<signed>(this->target_movement_time());
            ss << ", ";
            ss << "target_shoulderpitch=" << static_cast<signed>(this->target_shoulderpitch());
            ss << ", ";
            ss << "target_shoulderroll=" << static_cast<signed>(this->target_shoulderroll());
            ss << ", ";
            ss << "target_elbowroll=" << static_cast<signed>(this->target_elbowroll());
            ss << ", ";
            ss << "target_elbowyaw=" << static_cast<signed>(this->target_elbowyaw());
            ss << ", ";
            ss << "target_wristyaw=" << static_cast<signed>(this->target_wristyaw());
            ss << ", ";
            ss << "target_arm=" << static_cast<unsigned>(this->target_arm());
            ss << ", ";
            ss << "target_hand=" << static_cast<unsigned>(this->target_hand());
            ss << ", ";
            ss << "target_shoulderpitchstiffness=" << static_cast<unsigned>(this->target_shoulderpitchstiffness());
            ss << ", ";
            ss << "target_shoulderrollstiffness=" << static_cast<unsigned>(this->target_shoulderrollstiffness());
            ss << ", ";
            ss << "target_elbowrollstiffness=" << static_cast<unsigned>(this->target_elbowrollstiffness());
            ss << ", ";
            ss << "target_elbowyawstiffness=" << static_cast<unsigned>(this->target_elbowyawstiffness());
            ss << ", ";
            ss << "target_wristyawstiffness=" << static_cast<unsigned>(this->target_wristyawstiffness());
            ss << ", ";
            ss << "target_handstiffness=" << static_cast<unsigned>(this->target_handstiffness());
            ss << ", ";
            ss << "target_pliability=" << static_cast<unsigned>(this->target_pliability());
            ss << ", ";
            ss << "target_shoulderpitch_active=" << this->target_shoulderpitch_active();
            ss << ", ";
            ss << "target_shoulderroll_active=" << this->target_shoulderroll_active();
            ss << ", ";
            ss << "target_elbowroll_active=" << this->target_elbowroll_active();
            ss << ", ";
            ss << "target_elbowyaw_active=" << this->target_elbowyaw_active();
            ss << ", ";
            ss << "target_wrist_active=" << this->target_wrist_active();
            ss << ", ";
            ss << "target_hand_active=" << this->target_hand_active();
            ss << ", ";
            ss << "target_arm_at_goal=" << this->target_arm_at_goal();
            ss << ", ";
            ss << "target_arm_stop=" << this->target_arm_stop();
            return ss.str();
#endif /// USE_WB_HAL_ARM_TARGET_C_CONVERSION
        }

        std::string to_string() {
#ifdef USE_WB_HAL_ARM_TARGET_C_CONVERSION
            char buffer[HAL_ARM_TARGET_TO_STRING_BUFFER_SIZE];
            wb_hal_arm_target_to_string(this, buffer, sizeof(buffer));
            std::string toString = buffer;
            return toString;
#else
            std::ostringstream ss;
            ss << static_cast<signed>(this->target_movement_time());
            ss << ", ";
            ss << static_cast<signed>(this->target_shoulderpitch());
            ss << ", ";
            ss << static_cast<signed>(this->target_shoulderroll());
            ss << ", ";
            ss << static_cast<signed>(this->target_elbowroll());
            ss << ", ";
            ss << static_cast<signed>(this->target_elbowyaw());
            ss << ", ";
            ss << static_cast<signed>(this->target_wristyaw());
            ss << ", ";
            ss << static_cast<unsigned>(this->target_arm());
            ss << ", ";
            ss << static_cast<unsigned>(this->target_hand());
            ss << ", ";
            ss << static_cast<unsigned>(this->target_shoulderpitchstiffness());
            ss << ", ";
            ss << static_cast<unsigned>(this->target_shoulderrollstiffness());
            ss << ", ";
            ss << static_cast<unsigned>(this->target_elbowrollstiffness());
            ss << ", ";
            ss << static_cast<unsigned>(this->target_elbowyawstiffness());
            ss << ", ";
            ss << static_cast<unsigned>(this->target_wristyawstiffness());
            ss << ", ";
            ss << static_cast<unsigned>(this->target_handstiffness());
            ss << ", ";
            ss << static_cast<unsigned>(this->target_pliability());
            ss << ", ";
            ss << this->target_shoulderpitch_active();
            ss << ", ";
            ss << this->target_shoulderroll_active();
            ss << ", ";
            ss << this->target_elbowroll_active();
            ss << ", ";
            ss << this->target_elbowyaw_active();
            ss << ", ";
            ss << this->target_wrist_active();
            ss << ", ";
            ss << this->target_hand_active();
            ss << ", ";
            ss << this->target_arm_at_goal();
            ss << ", ";
            ss << this->target_arm_stop();
            return ss.str();
#endif /// USE_WB_HAL_ARM_TARGET_C_CONVERSION
        }

#ifdef USE_WB_HAL_ARM_TARGET_C_CONVERSION
        void from_string(const std::string &t_str) {
            wb_hal_arm_target_from_string(this, t_str.c_str());
#else
        void from_string(const std::string &t_str) {
            char * str_cstr = const_cast<char *>(t_str.c_str());
            size_t temp_length = strlen(str_cstr);
            int length = (temp_length <= INT_MAX) ? static_cast<int>(static_cast<ssize_t>(temp_length)) : -1;
            if (length < 1 || length > HAL_ARM_TARGET_DESC_BUFFER_SIZE) {
                return;
            }
            char var_str_buffer[HAL_ARM_TARGET_DESC_BUFFER_SIZE + 1];
            char* var_str = &var_str_buffer[0];
            char key_buffer[30];
            char* key = &key_buffer[0];
            int bracecount = 0;
            int startVar = 0;
            int index = 0;
            int startKey = 0;
            int endKey = -1;
            int varIndex = 0;
            if (index == 0 && str_cstr[0] == '{') {
                index = 1;
            }
            startVar = index;
            startKey = startVar;
            do {
                for (int i = index; i < length; i++) {
                    index = i + 1;
                    if (bracecount == 0 && str_cstr[i] == '=') {
                        endKey = i - 1;
                        startVar = index;
                        continue;
                    }
                    if (bracecount == 0 && isspace(str_cstr[i])) {
                        startVar = index;
                        if (endKey == -1) {
                            startKey = index;
                        }
                        continue;
                    }
                    if (bracecount == 0 && str_cstr[i] == ',') {
                        index = i - 1;
                        break;
                    }
                    if (str_cstr[i] == '{') {
                        bracecount++;
                        continue;
                    }
                    if (str_cstr[i] == '}') {
                        bracecount--;
                        if (bracecount < 0) {
                            index = i - 1;
                            break;
                        }
                    }
                    if (i == length - 1) {
                        index = i;
                    }
                }
                if (endKey >= startKey && endKey - startKey < length) {
                    strncpy(key, str_cstr + startKey, static_cast<size_t>((endKey - startKey) + 1));
                    key[(endKey - startKey) + 1] = 0;
                } else {
                    key[0] = 0;
                }
                strncpy(var_str, str_cstr + startVar, static_cast<size_t>((index - startVar) + 1));
                var_str[(index - startVar) + 1] = 0;
                bracecount = 0;
                index += 2;
                startVar = index;
                startKey = startVar;
                endKey = -1;
                if (strlen(key) > 0) {
                    if (0 == strcmp("target_movement_time", key)) {
                        varIndex = 0;
                    } else if (0 == strcmp("target_shoulderpitch", key)) {
                        varIndex = 1;
                    } else if (0 == strcmp("target_shoulderroll", key)) {
                        varIndex = 2;
                    } else if (0 == strcmp("target_elbowroll", key)) {
                        varIndex = 3;
                    } else if (0 == strcmp("target_elbowyaw", key)) {
                        varIndex = 4;
                    } else if (0 == strcmp("target_wristyaw", key)) {
                        varIndex = 5;
                    } else if (0 == strcmp("target_arm", key)) {
                        varIndex = 6;
                    } else if (0 == strcmp("target_hand", key)) {
                        varIndex = 7;
                    } else if (0 == strcmp("target_shoulderpitchstiffness", key)) {
                        varIndex = 8;
                    } else if (0 == strcmp("target_shoulderrollstiffness", key)) {
                        varIndex = 9;
                    } else if (0 == strcmp("target_elbowrollstiffness", key)) {
                        varIndex = 10;
                    } else if (0 == strcmp("target_elbowyawstiffness", key)) {
                        varIndex = 11;
                    } else if (0 == strcmp("target_wristyawstiffness", key)) {
                        varIndex = 12;
                    } else if (0 == strcmp("target_handstiffness", key)) {
                        varIndex = 13;
                    } else if (0 == strcmp("target_pliability", key)) {
                        varIndex = 14;
                    } else if (0 == strcmp("target_shoulderpitch_active", key)) {
                        varIndex = 15;
                    } else if (0 == strcmp("target_shoulderroll_active", key)) {
                        varIndex = 16;
                    } else if (0 == strcmp("target_elbowroll_active", key)) {
                        varIndex = 17;
                    } else if (0 == strcmp("target_elbowyaw_active", key)) {
                        varIndex = 18;
                    } else if (0 == strcmp("target_wrist_active", key)) {
                        varIndex = 19;
                    } else if (0 == strcmp("target_hand_active", key)) {
                        varIndex = 20;
                    } else if (0 == strcmp("target_arm_at_goal", key)) {
                        varIndex = 21;
                    } else if (0 == strcmp("target_arm_stop", key)) {
                        varIndex = 22;
                    } else {
                        varIndex = -1;
                    }
                }
                switch (varIndex) {
                    case -1: { break; }
                    case 0:
                    {
                        this->set_target_movement_time(static_cast<int32_t>(atoi(var_str)));
                        break;
                    }
                    case 1:
                    {
                        this->set_target_shoulderpitch(static_cast<int16_t>(atoi(var_str)));
                        break;
                    }
                    case 2:
                    {
                        this->set_target_shoulderroll(static_cast<int16_t>(atoi(var_str)));
                        break;
                    }
                    case 3:
                    {
                        this->set_target_elbowroll(static_cast<int16_t>(atoi(var_str)));
                        break;
                    }
                    case 4:
                    {
                        this->set_target_elbowyaw(static_cast<int16_t>(atoi(var_str)));
                        break;
                    }
                    case 5:
                    {
                        this->set_target_wristyaw(static_cast<int16_t>(atoi(var_str)));
                        break;
                    }
                    case 6:
                    {
                        this->set_target_arm(static_cast<uint8_t>(atoi(var_str)));
                        break;
                    }
                    case 7:
                    {
                        this->set_target_hand(static_cast<uint8_t>(atoi(var_str)));
                        break;
                    }
                    case 8:
                    {
                        this->set_target_shoulderpitchstiffness(static_cast<uint8_t>(atoi(var_str)));
                        break;
                    }
                    case 9:
                    {
                        this->set_target_shoulderrollstiffness(static_cast<uint8_t>(atoi(var_str)));
                        break;
                    }
                    case 10:
                    {
                        this->set_target_elbowrollstiffness(static_cast<uint8_t>(atoi(var_str)));
                        break;
                    }
                    case 11:
                    {
                        this->set_target_elbowyawstiffness(static_cast<uint8_t>(atoi(var_str)));
                        break;
                    }
                    case 12:
                    {
                        this->set_target_wristyawstiffness(static_cast<uint8_t>(atoi(var_str)));
                        break;
                    }
                    case 13:
                    {
                        this->set_target_handstiffness(static_cast<uint8_t>(atoi(var_str)));
                        break;
                    }
                    case 14:
                    {
                        this->set_target_pliability(static_cast<uint8_t>(atoi(var_str)));
                        break;
                    }
                    case 15:
                    {
                        this->set_target_shoulderpitch_active(static_cast<unsigned int>(atoi(var_str)));
                        break;
                    }
                    case 16:
                    {
                        this->set_target_shoulderroll_active(static_cast<unsigned int>(atoi(var_str)));
                        break;
                    }
                    case 17:
                    {
                        this->set_target_elbowroll_active(static_cast<unsigned int>(atoi(var_str)));
                        break;
                    }
                    case 18:
                    {
                        this->set_target_elbowyaw_active(static_cast<unsigned int>(atoi(var_str)));
                        break;
                    }
                    case 19:
                    {
                        this->set_target_wrist_active(static_cast<unsigned int>(atoi(var_str)));
                        break;
                    }
                    case 20:
                    {
                        this->set_target_hand_active(static_cast<unsigned int>(atoi(var_str)));
                        break;
                    }
                    case 21:
                    {
                        this->set_target_arm_at_goal(static_cast<unsigned int>(atoi(var_str)));
                        break;
                    }
                    case 22:
                    {
                        this->set_target_arm_stop(static_cast<unsigned int>(atoi(var_str)));
                        break;
                    }
                }
                if (varIndex >= 0) {
                    varIndex++;
                }
            } while(index < length);
#endif /// USE_WB_HAL_ARM_TARGET_C_CONVERSION
        }
#endif /// WHITEBOARD_POSTER_STRING_CONVERSION

#ifdef WHITEBOARD_POSTER_STRING_CONVERSION
                /**
                 *  Description function which prints values only
                 *  (Spreadsheet friendly)
                 */
                std::string valueDescription() {
#ifdef USE_WB_HAL_ARM_TARGET_C_CONVERSION
                    char buffer[HAL_ARM_TARGET_DESC_BUFFER_SIZE+22];
                    wb_hal_arm_target_value_description(this, buffer, sizeof(buffer));
                    std::string descr = buffer;
                    return descr;
#else
                        std::stringstream ss;
                        ss << static_cast<int>(target_shoulderpitch()) << " | "
                        << static_cast<int>(target_shoulderroll()) << " | "
                        << static_cast<int>(target_elbowroll()) << " | "
                        << static_cast<int>(target_elbowyaw()) << " | "
                        << static_cast<int>(target_wristyaw()) << " | "
                        << static_cast<int>(target_hand()) << " | "
                        << static_cast<int>(target_shoulderpitchstiffness()) << " | "
                        << static_cast<int>(target_shoulderrollstiffness()) << " | "
                        << static_cast<int>(target_elbowrollstiffness()) << " | "
                        << static_cast<int>(target_elbowyawstiffness()) << " | "
                        << static_cast<int>(target_wristyawstiffness()) << " | "
                        << static_cast<int>(target_handstiffness()) << " | "
                        << static_cast<int>(target_shoulderpitch_active()) << " | "
                        << static_cast<int>(target_shoulderroll_active()) << " | "
                        << static_cast<int>(target_elbowroll_active()) << " | "
                        << static_cast<int>(target_elbowyaw_active()) << " | "
                        << static_cast<int>(target_wrist_active()) << " | "
                        << static_cast<int>(target_hand_active()) << " | "
                        << static_cast<int>(target_movement_time()) << " | "
                        << static_cast<int>(target_pliability()) << " | "
                        << static_cast<int>(target_arm_at_goal()) << " | "
                        << static_cast<int>(target_arm_stop());
                        return ss.str();
                    }
#endif /// USE_WB_HAL_ARM_TARGET_C_CONVERSION
#endif /// WHITEBOARD_POSTER_STRING_CONVERSION

        //MARK: Arm - General
                    /**
                     *  Specify which arm this instance manages.
                     *  Up to 256 arms are possible.
                     *  Use prefedined macros LEFT_ARM and RIGHT_ARM for clarity.
                     *
                     *  @param  arm integer used to record which arm the object refers to.
                     *
                     */
                    void tieToArm(uint8_t arm)
                    {
                        set_target_arm(arm);
                    }

        //MARK: Arm - Movements

                    /**
                     * move to position in radians over a given time
                     * @param   shoulderpitch  down to up
                     * @param   shoulderroll   out to in
                     * @param   elbowroll      straight to bent
                     * @param   elbowyaw       rolled right to rolled left
                     * @param   wristyaw       rolled right to rolled left
                     * @param   hand           closed to open
                     * @param   time           elapsed time in mSec for the motion to complete.
                     *
                     */
                    void goToWithTime_Rad(float shoulderpitch,
                                          float shoulderroll,
                                          float elbowroll,
                                          float elbowyaw,
                                          float wristyaw,
                                          float hand,
                                          int32_t time = INT_MAX)
                    {
                        setPose_Rad(shoulderpitch, shoulderroll,
                                    elbowroll, elbowyaw,
                                    wristyaw, hand);
                        set_target_movement_time(time);
                    }

                    /**
                     * move to position expressed in degrees over a given time
                     * @param   shoulderpitch down to up
                     * @param   shoulderroll  out to in
                     * @param   elbowroll     straight to bent
                     * @param   elbowyaw      rolled right to rolled left
                     * @param   wristyaw      rolled right to rolled left
                     * @param   hand          closed to open
                     * @param   time          elapsed time in mSec for the motion to complete.
                     *
                     */
                    void goToWithTime_Deg(float shoulderpitch,
                                          float shoulderroll,
                                          float elbowroll,
                                          float elbowyaw,
                                          float wristyaw,
                                          float hand,
                                          int32_t time = INT_MAX)
                    {
                        setPose_Deg(shoulderpitch, shoulderroll,
                                    elbowroll, elbowyaw,
                                    wristyaw, hand);
                        set_target_movement_time(time);
                    }

                    /**
                     * Command the arm to stop at its current
                     * location and not act on motion commands
                     * until ready() is called.
                     *
                     */
                    void stop() {
                        set_target_arm_stop(true);
                    }


                    /**
                     * Set arm to ready state (Default)
                     * The arm will act on motion commands.
                     *
                     */
                    void ready() {
                        set_target_arm_stop(false);
                    }


                    /**
                     *  Arm at Goal Setter
                     *      Clients/Machines should not use this method.
                     *
                     *  Arm arrived at goal pose.
                     *  Only set in the status message by naoqiinterface when the arm has reached the goal pose.
                     *
                     *  @param  goalReached  the arm has reached the goal (true/false)
                     *
                     */
                    void isAtGoal(bool goalReached)
                    {
                        set_target_arm_at_goal(goalReached);
                    }

                    /**
                     *  Arm at Goal Getter
                     *      Clients/Machines should use this getter to test if the DCM
                     *      has reported that the arm has reached its goal pose.
                     *
                     *  Is the arm at the goal pose?
                     *  Naoqi Interface sets this true when the arm reaches the goal
                     *  pose asked for in the previous control message.
                     *
                     *  @return     bool    whether the arm is at the goal location or not.
                     *
                     */
                    bool atGoal()
                    {
                        return target_arm_at_goal();
                    }

                    /**
                     *  Client side test to determine if arm is at the target location, allowing for specified tolerances.
                     *  The method tests if the pose 'status' is within 'tolerance' of 'this' target
                     *  location, allowing for a specified tolerance.
                     *
                     *  'this' object contains the target pose settings.
                     *
                     *  @param  status      HalArmTarget object which contains actual pose settings reported by the robot's sensors.
                     *  @param  tolerance   HalArmTarget object whose pose settings specify the tolerance for each joint/gripper
                     *  @return bool        whether or not the status is within range of the target location.
                     *
                     */
                    bool atTargetLocation(HalArmTarget status, HalArmTarget tolerance)
                    {
                        int16_t shoulderpitchMargin = static_cast<int16_t>(abs(target_shoulderpitch() - status.target_shoulderpitch()));
                        int16_t shoulderrollMargin = static_cast<int16_t>(abs(target_shoulderroll() - status.target_shoulderroll()));
                        int16_t elbowrollMargin = static_cast<int16_t>(abs(target_elbowroll() - status.target_elbowroll()));
                        int16_t elbowyawMargin = static_cast<int16_t>(abs(target_elbowyaw() - status.target_elbowyaw()));
                        //#ifdef NAO_V3
                        //    int16_t wristyawMargin = static_cast<int16_t>(abs(target_wristyaw - status.target_wristyaw()));
                        //    uint8_t handMargin = static_cast<uint8_t>(abs(target_hand() - status.target_hand()));
                        if (   (shoulderpitchMargin <= tolerance.target_shoulderpitch())
                            && (shoulderrollMargin <= tolerance.target_shoulderroll())
                            && (elbowrollMargin <= tolerance.target_elbowroll())
                            && (elbowyawMargin <= tolerance.target_elbowyaw())
                            //#ifdef NAO_V3
                            //        && (wristyawMargin <= tolerance.target_wristyaw())
                            //        && (handMargin <= tolerance.target_hand())
                            )
                        {
                            return true;
                        }
                        return false;
                    }

        //MARK: Arm - Pose

                    /**
                     * Set Pose in radians
                     * @param   shoulderpitch  down to up
                     * @param   shoulderroll   out to in
                     * @param   elbowroll      straight to bent
                     * @param   elbowyaw       rolled right to rolled left
                     * @param   wristyaw       rolled right to rolled left
                     * @param   hand           closed to open.
                     *
                     */
                    void setPose_Rad(float shoulderpitch,
                                     float shoulderroll,
                                     float elbowroll,
                                     float elbowyaw,
                                     float wristyaw,
                                     float hand)
                    {
                        set_shoulderpitch_RAD(shoulderpitch);
                        set_shoulderroll_RAD(shoulderroll);
                        set_elbowroll_RAD(elbowroll);
                        set_elbowyaw_RAD(elbowyaw);
                        set_wristyaw_RAD(wristyaw);
                        set_hand(hand);
                    }

                    /**
                     * Set Pose in degrees
                     * @param   shoulderpitch down to up
                     * @param   shoulderroll  out to in
                     * @param   elbowroll     straight to bent
                     * @param   elbowyaw      rolled right to rolled left
                     * @param   wristyaw      rolled right to rolled left
                     * @param   hand          closed to open.
                     *
                     */
                    void setPose_Deg(float shoulderpitch,
                                     float shoulderroll,
                                     float elbowroll,
                                     float elbowyaw,
                                     float wristyaw,
                                     float hand)
                    {
                        set_shoulderpitch_DEG(shoulderpitch);
                        set_shoulderroll_DEG(shoulderroll);
                        set_elbowroll_DEG(elbowroll);
                        set_elbowyaw_DEG(elbowyaw);
                        set_wristyaw_DEG(wristyaw);
                        set_hand(hand);
                    }


                    /**
                     *  Convenience function to mirror arm settings about the XZ plane from one HalArmTarget object to another.
                     *
                     *  @param  other    HalArmTarget object to be mirrored.
                     *
                     */
                    void mirrorArm(const HalArmTarget &other)
                    {
                        // Roll and Yaw angles need to be mirrored, others just copied.
                        set_target_shoulderpitch(other.target_shoulderpitch());
                        set_target_shoulderroll(-other.target_shoulderroll());
                        set_target_elbowroll(-other.target_elbowroll());
                        set_target_elbowyaw(-other.target_elbowyaw());
                        set_target_wristyaw(-other.target_wristyaw());
                        set_target_hand(other.target_hand());
                        set_target_shoulderpitchstiffness(other.target_shoulderpitchstiffness());
                        set_target_shoulderrollstiffness(other.target_shoulderrollstiffness());
                        set_target_elbowrollstiffness(other.target_elbowrollstiffness());
                        set_target_elbowyawstiffness(other.target_elbowyawstiffness());
                        set_target_wristyawstiffness(other.target_wristyawstiffness());
                        set_target_handstiffness(other.target_handstiffness());
                        set_target_shoulderpitch_active(other.target_shoulderpitch_active());
                        set_target_shoulderroll_active(other.target_shoulderroll_active());
                        set_target_elbowroll_active(other.target_elbowroll_active());
                        set_target_elbowyaw_active(other.target_elbowyaw_active());
                        set_target_wrist_active(other.target_wrist_active());
                        set_target_hand_active(other.target_hand_active());
                        set_target_movement_time(other.target_movement_time());
                        set_target_pliability(other.target_pliability());
                    }

                    /**
                     *  Convenience function to copy pose settings from one HalArmTarget object to another.
                     *
                     *  @param  other    HalArmTarget object from which to copy pose settings from.
                     *
                     */
                    void copyPose(const HalArmTarget &other)
                    {
                        set_target_shoulderpitch(other.target_shoulderpitch());
                        set_target_shoulderroll(other.target_shoulderroll());
                        set_target_elbowroll(other.target_elbowroll());
                        set_target_elbowyaw(other.target_elbowyaw());
                        set_target_wristyaw(other.target_wristyaw());
                        set_target_hand(other.target_hand());
                    }

                    /**
                     *  Convenience function to mirror pose settings about the XZ plane from one HalArmTarget object to another.
                     *
                     *  @param  other    HalArmTarget object whose pose settings are to be mirrored.
                     *
                     */
                    void mirrorPose(const HalArmTarget &other)
                    {
                        set_target_shoulderpitch(other.target_shoulderpitch());
                        set_target_shoulderroll(-other.target_shoulderroll());
                        set_target_elbowroll(-other.target_elbowroll());
                        set_target_elbowyaw(-other.target_elbowyaw());
                        set_target_wristyaw(-other.target_wristyaw());
                        set_target_hand(other.target_hand());
                    }

                    /**
                     *  Tests if this HalArmTarget object has the same pose settings as the other HalArmTarget object.
                     *      NOTE this does not take into account mirroring about the XZ plane.
                     *
                     *  @param  other   HalArmTarget object whose pose settings are being compared.
                     *  @return bool    whether the two objects have the same pose or not.
                     *
                     */
                    bool hasSamePose(const HalArmTarget &other)
                    {
                        if (
                            target_shoulderpitch() == other.target_shoulderpitch()
                            && target_shoulderroll() == other.target_shoulderroll()
                            && target_elbowroll() == other.target_elbowroll()
                            && target_elbowyaw() == other.target_elbowyaw()
                            && target_wristyaw() == other.target_wristyaw()
                            && target_hand() == other.target_hand()
                            )
                        {
                            return  true;
                        }
                        return false;
                    }

                    /**
                     *  Tests if this HalArmTarget object has the same mirrored pose settings as the other HalArmTarget object.
                     *      NOTE this method takes into account mirroring about the XZ plane.
                     *
                     *  @param  other   HalArmTarget object whose pose settings are being compared.
                     *  @return bool    whether the two objects have the same pose or not.
                     *
                     */
                    bool hasSameMirroredPose(const HalArmTarget &other)
                    {
                        if (
                            target_shoulderpitch() == other.target_shoulderpitch()
                            && target_shoulderroll() == -other.target_shoulderroll()
                            && target_elbowroll() == -other.target_elbowroll()
                            && target_elbowyaw() == -other.target_elbowyaw()
                            && target_wristyaw() == -other.target_wristyaw()
                            && target_hand() == other.target_hand()
                            )
                        {
                            return  true;
                        }
                        return false;
                    }

        //MARK: Arm - Stiffness

                    /**
                     *  Convenience function to set the stiffness
                     *  of all the arm's joints to the maximum (1.0f).
                     *
                     */
                    void setArmStiffnessMax()
                    {
                        set_shoulderpitchstiffness(1.0f);
                        set_shoulderrollstiffness(1.0f);
                        set_elbowrollstiffness(1.0f);
                        set_elbowyawstiffness(1.0f);
                        set_wristyawstiffness(1.0f);
                        set_handstiffness(1.0f);
                    }

                    /**
                     *  Convenience function to set the stiffness
                     *  of all the arm's joints to what Aldebaran
                     *  considers 'normal' (0.6f).
                     *
                     */
                    void setArmStiffnessNormal()
                    {
                        set_shoulderpitchstiffness(0.6f);
                        set_shoulderrollstiffness(0.6f);
                        set_elbowrollstiffness(0.6f);
                        set_elbowyawstiffness(0.6f);
                        set_wristyawstiffness(0.6f);
                        set_handstiffness(0.6f);
                    }

                    /**
                     *  Convenience function to set uniform stiffness
                     *  on all arm joints to a custom value.
                     *
                     *  @param stiffness float Stiffness setting between 0.0 and 1.0 (float).
                     *
                     */
                    void setArmStiffness(float stiffness)
                    {
                        if ((stiffness <= 1.0f) && (stiffness >=0.0f)) {
                            set_shoulderpitchstiffness(stiffness);
                            set_shoulderrollstiffness(stiffness);
                            set_elbowrollstiffness(stiffness);
                            set_elbowyawstiffness(stiffness);
                            set_wristyawstiffness(stiffness);
                            set_handstiffness(stiffness);
                        }
                    }

                    /**
                     *  Convenience function to turn off stiffness
                     *  in all the arm's joints (0.0f).
                     *
                     */
                    void setArmStiffnessOff()
                    {
                        set_shoulderpitchstiffness(0.0f);
                        set_shoulderrollstiffness(0.0f);
                        set_elbowrollstiffness(0.0f);
                        set_elbowyawstiffness(0.0f);
                        set_wristyawstiffness(0.0f);
                        set_handstiffness(0.0f);
                    }


                    /**
                     *  Convenience function to copy stiffness settings from one HalArmTarget object to another.
                     *
                     *  @param  other    HalArmTarget object from which to copy stiffness settings.
                     *
                     */
                    void copyStiffness(const HalArmTarget &other)
                    {
                        set_target_shoulderpitchstiffness(other.target_shoulderpitchstiffness());
                        set_target_shoulderrollstiffness(other.target_shoulderrollstiffness());
                        set_target_elbowrollstiffness(other.target_elbowrollstiffness());
                        set_target_elbowyawstiffness(other.target_elbowyawstiffness());
                        set_target_wristyawstiffness(other.target_wristyawstiffness());
                        set_target_handstiffness(other.target_handstiffness());
                    }



                    /**
                     *  Tests if this HalArmTarget object has the same stiffness settings as the other HalArmTarget object.
                     *
                     *  @param  other   HalArmTarget object whose stiffness settings are being compared.
                     *  @return bool    whether the two objects have the same stiffness or not.
                     *
                     */
                    bool hasSameStiffness(const HalArmTarget &other)
                    {
                        if (
                            target_shoulderpitchstiffness() == other.target_shoulderpitchstiffness()
                            && target_shoulderrollstiffness() == other.target_shoulderrollstiffness()
                            && target_elbowrollstiffness() == other.target_elbowrollstiffness()
                            && target_elbowyawstiffness() == other.target_elbowyawstiffness()
                            && target_wristyawstiffness() == other.target_wristyawstiffness()
                            && target_handstiffness() == other.target_handstiffness()
                           )
                        {
                            return  true;
                        }
                        return false;
                    }

        //MARK: Arm - Pliability

                    /**
                     *  Set arm to be Active (DEDAULT DCM state)
                     *  The arm is active and manual movements will be resisted, be careful when the stiffness is set high.
                     *  Once the applied force is removed, the arm will return to its previous location.
                     *  Be careful using this with high stiffness settings (which vary per joint), as the gears will be stripped.
                     *
                     *  NOTE:  This is the default DCM mode.
                     *
                     */
                    void setArmActive()
                    {
                        set_target_shoulderpitch_active(true);
                        set_target_shoulderroll_active(true);
                        set_target_elbowroll_active(true);
                        set_target_elbowyaw_active(true);
                        set_target_wrist_active(true);
                        set_target_hand_active(true);
                    }

                    /**
                     *  Set arm to be Passive
                     *  Manually moving the arm causes the arm to remain in the new position.
                     *  Be careful using this with high stiffness and pliability settings (which vary per joint).
                     *
                     *  NOTE:  This is achieved by telling the DCM to move the arm to the displaced
                     *         position each DCM cyle.  Thus the arm tracks the applied force.
                     *         The 'pliability' setting reduces the update rate, thus making the arm stiffer. At
                     *         higher pliability settings, the movement will become noticably stepped.
                     *
                     */
                    void setArmPassive()
                    {
                        set_target_shoulderpitch_active(false);
                        set_target_shoulderroll_active(false);
                        set_target_elbowroll_active(false);
                        set_target_elbowyaw_active(false);
                        set_target_wrist_active(false);
                        set_target_hand_active(false);
                    }


                    /**
                     *  Individually set the active/passive state of each joint.
                     *  See Arm_Active() and Arm_Passive() methods for an explanation of the Active/Passive effect.
                     *
                     */
                    void setArmPliability(bool shoulderpitch, bool shoulderroll, bool elbowroll,
                                        bool elbowyaw, bool wristyaw, bool hand)
                    {
                        set_target_shoulderpitch_active(shoulderpitch);
                        set_target_shoulderroll_active(shoulderroll);
                        set_target_elbowroll_active(elbowroll);
                        set_target_elbowyaw_active(elbowyaw);
                        set_target_wrist_active(wristyaw);
                        set_target_hand_active(hand);
                    }

                    /**
                     *  Are any of the arm's joints set to passive
                     *
                     */
                    bool isArmPassive() {
                        return !target_shoulderpitch_active() || !target_shoulderroll_active() || !target_elbowroll_active() || !target_elbowyaw_active() || !target_wrist_active() || !target_hand_active();
                    }

                    /**
                     *  Are all of the arm's joints set to passive
                     *
                     */
                    bool isArmAllPassive() {
                        return !target_shoulderpitch_active() && !target_shoulderroll_active() && !target_elbowroll_active() && !target_elbowyaw_active() && !target_wrist_active() && !target_hand_active();
                    }

                    /**
                     *  Are all of the arm's joints set to active
                     *
                     */
                    bool isArmAllActive() {
                        return target_shoulderpitch_active() && target_shoulderroll_active() && target_elbowroll_active() && target_elbowyaw_active() && target_wrist_active() && target_hand_active();
                    }

        //MARK: CUSTOM SETTERS (Converting floats into Integer representations)
        /// Movement Setters (Degrees)
                    void set_shoulderpitch_DEG(float setting) {
                        set_target_shoulderpitch(static_cast<int16_t>(setting * 10.0f));
                    }

                    void set_shoulderroll_DEG(float setting) {
                        set_target_shoulderroll(static_cast<int16_t>(setting * 10.0f));
                    }

                    void set_elbowroll_DEG(float setting) {
                        set_target_elbowroll(static_cast<int16_t>(setting * 10.0f));
                    }

                    void set_elbowyaw_DEG(float setting) {
                        set_target_elbowyaw(static_cast<int16_t>(setting * 10.0f));
                    }

                    void set_wristyaw_DEG(float setting) {
                        set_target_wristyaw(static_cast<int16_t>(setting * 10.0f));
                    }

        /// Movement Setters (Radians)
                    void set_shoulderpitch_RAD(float setting) {
                        set_target_shoulderpitch(static_cast<int16_t>(setting* DEG_OVER_RAD_10));
                    }

                    void set_shoulderroll_RAD(float setting) {
                        set_target_shoulderroll(static_cast<int16_t>(setting * DEG_OVER_RAD_10));
                    }

                    void set_elbowroll_RAD(float setting) {
                        set_target_elbowroll(static_cast<int16_t>(setting * DEG_OVER_RAD_10));
                    }

                    void set_elbowyaw_RAD(float setting) {
                        set_target_elbowyaw(static_cast<int16_t>(setting * DEG_OVER_RAD_10));
                    }

                    void set_wristyaw_RAD(float setting) {
                        set_target_wristyaw(static_cast<int16_t>(setting * DEG_OVER_RAD_10));
                    }

        /// Hand Movement Setter
                    void set_hand(float setting) {
                        set_target_hand(static_cast<uint8_t>(setting * 100.0f));
                    }

        /// Stiffness Setters
                    void set_shoulderpitchstiffness(float setting) {
                        set_target_shoulderpitchstiffness(static_cast<uint8_t>(setting * 100.0f));
                    }

                    void set_shoulderrollstiffness(float setting) {
                        set_target_shoulderrollstiffness(static_cast<uint8_t>(setting * 100.0f));
                    }

                    void set_elbowrollstiffness(float setting) {
                        set_target_elbowrollstiffness(static_cast<uint8_t>(setting * 100.0f));
                    }

                    void set_elbowyawstiffness(float setting) {
                        set_target_elbowyawstiffness(static_cast<uint8_t>(setting * 100.0f));
                    }

                    void set_wristyawstiffness(float setting) {
                        set_target_wristyawstiffness(static_cast<uint8_t>(setting * 100.0f));
                    }

                    void set_handstiffness(float setting) {
                        set_target_handstiffness(static_cast<uint8_t>(setting * 100.0f));
                    }


        ///// Duration Setter
        //            void set_movement_time(int32_t time) {
        //                set_target_movement_time(time);
        //            }

        //MARK: CUSTOM GETTERS (Converting Integer representations back to floats)
        /// Movement Getters (Degrees)
                    float get_shoulderpitch_DEG() {
                        return static_cast<float>(target_shoulderpitch() * 0.1f);
                    }

                    float get_shoulderroll_DEG() {
                        return static_cast<float>(target_shoulderroll() * 0.1f);
                    }

                    float get_elbowroll_DEG() {
                        return static_cast<float>(target_elbowroll() * 0.1f);
                    }

                    float get_elbowyaw_DEG() {
                        return static_cast<float>(target_elbowyaw() * 0.1f);
                    }

                    float get_wristyaw_DEG() {
                        return static_cast<float>(target_wristyaw() * 0.1f);
                    }

        /// Movement Getters (Radians)
                    float get_shoulderpitch_RAD() {
                        return static_cast<float>(target_shoulderpitch()) * RAD_OVER_DEG_10;
                    }

                    float get_shoulderroll_RAD() {
                        return static_cast<float>(target_shoulderroll()) * RAD_OVER_DEG_10;
                    }

                    float get_elbowroll_RAD() {
                        return static_cast<float>(target_elbowroll()) * RAD_OVER_DEG_10;
                    }

                    float get_elbowyaw_RAD() {
                        return static_cast<float>(target_elbowyaw()) * RAD_OVER_DEG_10;
                    }

                    float get_wristyaw_RAD() {
                        return static_cast<float>(target_wristyaw()) * RAD_OVER_DEG_10;
                    }

        /// Hand Movement Getter
                    float get_hand() {
                        return static_cast<float>(target_hand()) * 0.01f;
                    }

        /// Stiffness Getters
                    float get_shoulderpitchstiffness() {
                        return static_cast<float>(target_shoulderpitchstiffness()) * 0.01f;
                    }

                    float get_shoulderrollstiffness() {
                        return static_cast<float>(target_shoulderrollstiffness()) * 0.01f;
                    }

                    float get_elbowrollstiffness() {
                        return static_cast<float>(target_elbowrollstiffness()) * 0.01f;
                    }

                    float get_elbowyawstiffness() {
                        return static_cast<float>(target_elbowyawstiffness()) * 0.01f;
                    }

                    float get_wristyawstiffness() {
                        return static_cast<float>(target_wristyawstiffness()) * 0.01f;
                    }

                    float get_handstiffness() {
                        return static_cast<float>(target_handstiffness()) * 0.01f;
                    }
    };

} /// namespace guWhiteboard

#endif /// HalArmTarget_DEFINED
